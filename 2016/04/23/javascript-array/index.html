<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript原生数组 - Gnipbao&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="说明 数组是类似列表的对象，在原型中提供了一些遍历以及改变其中对象的方法。JavaScript数组的长度及其中元素的类型都是不固定的。因为数组的长度可以随时增长或缩减，所以JavaScript 数组不保证是密集的。通常情况下，这是一些方便的特性；如果这些特性不适用于你的特定使用场景，你可以考虑使用固定类型数组。在JavaScript中数组可以使用数组构造函Array被创建,为了方便一般用中括号[]">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript原生数组">
<meta property="og:url" content="https://gnipbao.github.io/2016/04/23/javascript-array/index.html">
<meta property="og:site_name" content="Gnipbao&#39;s blog">
<meta property="og:description" content="说明 数组是类似列表的对象，在原型中提供了一些遍历以及改变其中对象的方法。JavaScript数组的长度及其中元素的类型都是不固定的。因为数组的长度可以随时增长或缩减，所以JavaScript 数组不保证是密集的。通常情况下，这是一些方便的特性；如果这些特性不适用于你的特定使用场景，你可以考虑使用固定类型数组。在JavaScript中数组可以使用数组构造函Array被创建,为了方便一般用中括号[]">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://gnipbao.github.io/images/Array.png">
<meta property="og:updated_time" content="2016-05-04T14:10:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript原生数组">
<meta name="twitter:description" content="说明 数组是类似列表的对象，在原型中提供了一些遍历以及改变其中对象的方法。JavaScript数组的长度及其中元素的类型都是不固定的。因为数组的长度可以随时增长或缩减，所以JavaScript 数组不保证是密集的。通常情况下，这是一些方便的特性；如果这些特性不适用于你的特定使用场景，你可以考虑使用固定类型数组。在JavaScript中数组可以使用数组构造函Array被创建,为了方便一般用中括号[]">
<meta name="twitter:image" content="https://gnipbao.github.io/images/Array.png">
  
    <link rel="alternative" href="/atom.xml" title="Gnipbao&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/favicon.ico">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <a href="https://github.com/gnipbao/iblog" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Gnipbao</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/h5-test/menu.html">作品</a>
        
          <a class="main-nav-link" href="/me">关于</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <!--<p>-->
            <!--<a target="_blank" href="http://shang.qq.com/wpa/qunwpa?idkey=6071b891d167a94217254d0d36cec8a338df210ca5831dd09950740807f5da97"><img border="0" src="http://pub.idqqimg.com/wpa/images/group.png" alt="前端联盟" title="前端联盟"></a>-->
          <!--</p>-->
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-javascript-array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript原生数组
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/04/23/javascript-array/" class="article-date">
  <time datetime="2016-04-23T02:58:51.000Z" itemprop="datePublished">2016-04-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/写作/">写作</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p> 数组是类似列表的对象，在原型中提供了一些遍历以及改变其中对象的方法。JavaScript数组的长度及其中元素的类型都是不固定的。因为数组的长度可以随时增长或缩减，所以JavaScript 数组不保证是密集的。通常情况下，这是一些方便的特性；如果这些特性不适用于你的特定使用场景，你可以考虑使用固定类型数组。在JavaScript中数组可以使用数组构造函<code>Array</code>被创建,为了方便一般用中括号<code>[]</code>创建,<code>Arrays</code>继承<code>Object</code>的原型.<code>typeof</code>检测数组的类型会返回<code>object</code>,可是使用[]instanceof Array,会返回true,也就是说在JavaScript中存在类似数组的<code>Array-like</code>的对象<code>objects</code>,例如:strings,<code>arguments</code>对象,arguments对象不是数组的实例,但是它有<code>length</code>属性,它的值和数组的下标属性之间是有关系的并且length是可变的(例如, push, splice, 等) 会改变<code>Array</code>的 <code>length</code>属性。因此它可以像任何数组一样去遍历.这篇文章主要介绍一些<code>Array.prototype</code>中常用的方法,尽可能揭开每一种方法的真面纱。</p>
<p> <img src="/images/Array.png" alt="JavaScript-Array"><br> 你可以在你的浏览器控制台里面尝试！<br><a id="more"></a> </p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><code>.forEach</code>循环</li>
<li><code>.some</code>和<code>.every</code>检测</li>
<li><code>.join</code>和<code>.concat</code>细微差别</li>
<li><code>.pop</code>,<code>.push</code>,<code>.shift</code>,和<code>.unshift</code>模拟堆栈</li>
<li><code>.map</code>映射</li>
<li><code>.filter</code>过滤测试</li>
<li><code>.sort</code>排序</li>
<li><code>.reduce</code>,<code>.reduceRight</code>累加器</li>
<li><code>.slice</code>复制(copy)</li>
<li><code>.splice</code>修改(update)</li>
<li><code>.indexOf</code>查找</li>
<li><code>.reverse</code>逆序<h3 id="forEeah循环"><a href="#forEeah循环" class="headerlink" title="forEeah循环"></a>forEeah循环</h3><code>array.forEach(callback[,thisArg])</code>forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过(但不包括哪些值为 undefined 的项),这个给定的回调函数可以传入三个参数</li>
</ul>
<ul>
<li>callback 给定执行的回调函数<ul>
<li><code>value</code> 数组当前项的值</li>
<li><code>index</code> 当前的索引(或下标)</li>
<li><code>array</code> 数组本身</li>
</ul>
</li>
<li>thisArg 可选参数。用来当作callback 函数内this的值的对象。 </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'_'</span>, <span class="string">'t'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'i'</span>, <span class="string">'f'</span>, <span class="string">']'</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.push(<span class="built_in">String</span>.fromCharCode(value.charCodeAt() + index + <span class="number">2</span>))</span><br><span class="line">&#125;, out = [])</span><br><span class="line"></span><br><span class="line">out.join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">//&lt;-'awesome'</span></span><br></pre></td></tr></table></figure>
<h3 id="some和every"><a href="#some和every" class="headerlink" title="some和every"></a>some和every</h3><p><code>array.some(callback[,thisArg])</code>some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 <code>true</code>。否则，some 返回 <code>false</code>。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。some调用不改变数组。some 遍历的元素的范围在第一次调用 callback. 时就已经确定了。在调用 some 后被添加到数组中的值不会被 callback 访问到。如果数组中存在且还未被访问到的元素被 callback 改变了，则其传递给 callback 的值是 some 访问到它那一刻的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max = -<span class="literal">Infinity</span></span><br><span class="line">satisfied = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">23</span>].some(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (value &gt; max) max = value</span><br><span class="line">	<span class="keyword">return</span> value &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br><span class="line"><span class="comment">// &lt;- 12</span></span><br><span class="line">satisfied</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure></p>
<p><code>array.every(callback[,thisArg])</code> every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。every也不会改变数组,遍历元素的范围和值与some基本一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">passed = [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p>
<p>总结下:some其实就相当与检测数组中是否<strong>存在</strong>使callback返回<code>true</code>的值.而every是检测数组中<strong>任意</strong>值都能使callback返回<code>true</code>.这里的<code>true</code>指的是可以转换为布尔值的元素.</p>
<h3 id="join和concat"><a href="#join和concat" class="headerlink" title="join和concat"></a>join和concat</h3><p><code>str = arr.join([separator = &#39;,&#39;])</code> join方法将所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null，则会转化成空字符串。</p>
<ul>
<li>separator 可选,用于指定连接每个数组元素的分隔符。分隔符会被转成字符串类型;如果省略的话,默认为一个逗号。如果 seprator 是一个空字符串,那么数组中的所有元素将被直接连接。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'Wind'</span>, <span class="string">'Rain'</span>, <span class="string">'Fire'</span>];</span><br><span class="line"><span class="keyword">var</span> myVar1 = a.join();      <span class="comment">// myVar1的值变为"Wind,Rain,Fire"</span></span><br><span class="line"><span class="keyword">var</span> myVar2 = a.join(<span class="string">', '</span>);  <span class="comment">// myVar2的值变为"Wind, Rain, Fire"</span></span><br><span class="line"><span class="keyword">var</span> myVar3 = a.join(<span class="string">' + '</span>); <span class="comment">// myVar3的值变为"Wind + Rain + Fire"</span></span><br><span class="line"><span class="keyword">var</span> myVar4 = a.join(<span class="string">''</span>);    <span class="comment">// myVar4的值变为"WindRainFire"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>array.concat(value1, value2, ..., valueN)</code>concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.<br>concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.<code>array.concat()</code>如果没有参数传入,就会返回array的一个<strong>浅复制</strong>.对新数组的任何操作都不会对原数组产生影响,反之亦然.原数组中的元素有两种被拷贝的方式:</p>
<ul>
<li>对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>
<li>字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alpha = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">var</span> numeric = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 组成新数组 ["a", "b", "c", 1, 2, 3]; 原数组 alpha 和 numeric 未被修改</span></span><br><span class="line"><span class="keyword">var</span> alphaNumeric = alpha.concat(numeric);</span><br><span class="line"><span class="keyword">var</span> num1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> num2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> num3 = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="comment">// 组成新数组[1, 2, 3, 4, 5, 6, 7, 8, 9]; 原数组 num1, num2, num3 未被修改</span></span><br><span class="line"><span class="keyword">var</span> nums = num1.concat(num2, num3);</span><br><span class="line"><span class="keyword">var</span> alpha = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="comment">// 组成新数组 ["a", "b", "c", 1, 2, 3], 原alpha数组未被修改</span></span><br><span class="line"><span class="keyword">var</span> alphaNumeric = alpha.concat(<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="pop，push和shift，unshift模拟堆栈"><a href="#pop，push和shift，unshift模拟堆栈" class="headerlink" title="pop，push和shift，unshift模拟堆栈"></a>pop，push和shift，unshift模拟堆栈</h3><p><code>array.pop()</code> pop方法删除一个数组中的最后一个元素，并且把这个删除掉的元素返回给调用者。pop 被有意设计成具有通用性，该方法可以通过 <code>call</code> 或 <code>apply</code> 方法应用于一个类数组（array-like）对象上。</p>
<p><code>arr.push(element1, ..., elementN)</code> push方法push 方法把值添加到数组中。push 方法有意具有通用性。该方法和 <code>call()</code> 或 <code>apply()</code> 一起使用时，可应用在类似数组的对象上。push 方法根据 length 属性来决定从哪里开始插入给定的值。如果 length 不能被转成一个数值，则插入的元素索引为 0，包括 length 不存在时。当 length不存在时，将会创建它。唯一的原生类数组（array-like）对象是 <code>Strings</code>，尽管如此，它们并不适用该方法，因为字符串是不可改变的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vegetables = [<span class="string">'parsnip'</span>, <span class="string">'potato'</span>];</span><br><span class="line"><span class="keyword">var</span> moreVegs = [<span class="string">'celery'</span>, <span class="string">'beetroot'</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(vegetables, moreVegs);</span><br><span class="line"><span class="built_in">console</span>.log(vegetables); <span class="comment">// ['parsnip', 'potato', 'celery', 'beetroot']</span></span><br></pre></td></tr></table></figure></p>
<p><code>array.shift()</code> shift 方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素，其他元素的索引值随之减 1。如果 length 属性的值为 0 (长度为 0)，则返回 <code>undefined</code>。 shift 方法并不局限于数组：该方法亦可通过 <code>call</code> 或 <code>apply</code> 作用于对象上。对于不包含 length 属性的对象，将添加一个值为 0 的 length 属性。</p>
<p><code>arr.unshift(element1, ..., elementN)</code> unshift 方法会在调用它的类数组（array-like）对象的开始位置插入给定的参数。unshift 特意被设计成具有通用性；这个方法能够通过 <code>call</code> 或 <code>apply</code> 方法作用于类似数组的对象上。不过对于没有 length 属性（代表从0开始的一系列连续的数字属性的最后一个）的对象，调用该方法可能没有任何意义。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="number">0</span>); <span class="comment">//result of call is 3, the new array length</span></span><br><span class="line"><span class="comment">//arr is [0, 1, 2]</span></span><br><span class="line">arr.unshift(<span class="number">-2</span>, <span class="number">-1</span>); <span class="comment">// = 5</span></span><br><span class="line"><span class="comment">//arr is [-2, -1, 0, 1, 2]</span></span><br><span class="line">arr.unshift( [<span class="number">-3</span>] );</span><br><span class="line"><span class="comment">//arr is [[-3], -2, -1, 0, 1, 2]</span></span><br></pre></td></tr></table></figure></p>
<p>模拟LIFO(last in first out)栈<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>._stack = []</span><br><span class="line">&#125;</span><br><span class="line">Stack.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._stack.pop()</span><br><span class="line">&#125;</span><br><span class="line">Stack.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._stack.push.apply(<span class="keyword">this</span>._stack, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">stack = <span class="keyword">new</span> Stack()</span><br><span class="line">stack.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">stack.next()</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure></p>
<p>模拟FIFO(first in first out)堆<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>._queue = []</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._queue.shift()</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._queue.unshift.apply(<span class="keyword">this</span>._queue, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">queue = <span class="keyword">new</span> Queue()</span><br><span class="line">queue.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">queue.next()</span><br><span class="line"><span class="comment">// &lt;- 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>array.map(callback[, thisArg])</code> map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。</p>
<ul>
<li>callback 给定执行的回调函数<ul>
<li><code>value</code> 数组当前项的值</li>
<li><code>index</code> 当前的索引(或下标)</li>
<li><code>array</code> 数组本身</li>
</ul>
</li>
<li>thisArg 可选参数。用来当作callback 函数内this的值的对象。<br>如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象。<br>map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="keyword">void</span> <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>]</span><br><span class="line">values[<span class="number">7</span>] = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">result = values.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [undefined, null, false, '', undefined × 3, undefined]</span></span><br><span class="line"><span class="comment">// 通常使用parseInt时,只需要传递一个参数.但实际上,parseInt可以有两个参数.第二个参数是进制数.可以通过语句"alert(parseInt.length)===2"来验证.</span></span><br><span class="line">[<span class="number">1</span>, <span class="string">'2'</span>, <span class="string">'30'</span>, <span class="string">'9'</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(value, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1, 2, 30, 9</span></span><br><span class="line">[<span class="number">97</span>, <span class="number">119</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>].map(<span class="built_in">String</span>.fromCharCode).join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// &lt;- 'awesome'</span></span><br><span class="line"><span class="comment">// a commonly used pattern is mapping to new objects</span></span><br><span class="line">items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		id: item.id,</span><br><span class="line">		name: computeName(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>array.filter(callback[, thisArg])</code> filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。    callback 被调用时传入三个参数：元素的值,元素的索引,被遍历的数组.如果为 filter 提供一个 thisArg参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为undefined。filter和上面的some,every,forEach,map 具有相同的特性;不会改变原数组。filter遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">void</span> <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>, <span class="number">1</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [1]</span></span><br><span class="line">[<span class="keyword">void</span> <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>, <span class="number">1</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [void 0, null, false, '']</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><code>arr.sort([compareFunction])</code> sort()方法对数组的元素做原地的排序，并返回这个数组。 sort 可能不是稳定的。默认按照字符串的Unicode码位点（code point）排序。如果没有指明 compareFunction ，那么元素会被转换为字符串并按照万国码位点顺序排序。例如 “Cherry” 会被排列到 “banana” 之前。当对数字进行排序的时候， 9 会出现在 80 之后，因为他们会先被转换为字符串，而 “80” 比 “9” 要靠前。如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素：</p>
<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</li>
<li>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringArray = [<span class="string">"Blue"</span>, <span class="string">"Humpback"</span>, <span class="string">"Beluga"</span>];</span><br><span class="line"><span class="keyword">var</span> numericStringArray = [<span class="string">"80"</span>, <span class="string">"9"</span>, <span class="string">"700"</span>];</span><br><span class="line"><span class="keyword">var</span> numberArray = [<span class="number">40</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">200</span>];</span><br><span class="line"><span class="keyword">var</span> mixedNumericArray = [<span class="string">"80"</span>, <span class="string">"9"</span>, <span class="string">"700"</span>, <span class="number">40</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareNumbers</span>(<span class="params">a, b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'stringArray:'</span>, stringArray.join());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted:'</span>, stringArray.sort());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'numberArray:'</span>, numberArray.join());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted without a compare function:'</span>, numberArray.sort());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted with compareNumbers:'</span>, numberArray.sort(compareNumbers));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'numericStringArray:'</span>, numericStringArray.join());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted without a compare function:'</span>, numericStringArray.sort());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted with compareNumbers:'</span>, numericStringArray.sort(compareNumbers));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'mixedNumericArray:'</span>, mixedNumericArray.join());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted without a compare function:'</span>, mixedNumericArray.sort());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Sorted with compareNumbers:'</span>, mixedNumericArray.sort(compareNumbers));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对非 ASCII 字符排序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="string">'réservé'</span>, <span class="string">'premier'</span>, <span class="string">'cliché'</span>, <span class="string">'communiqué'</span>, <span class="string">'café'</span>, <span class="string">'adieu'</span>];</span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// items is ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']</span></span><br></pre></td></tr></table></figure></p>
<p>使用映射改善排序<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要被排序的数组</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">'Delta'</span>, <span class="string">'alpha'</span>, <span class="string">'CHARLIE'</span>, <span class="string">'bravo'</span>]</span><br><span class="line"><span class="comment">// 对需要排序的数字和位置的临时存储</span></span><br><span class="line"><span class="keyword">var</span> mapped = list.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">index</span>: i, <span class="attr">value</span>: el.toLowerCase() &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 按照多个值排序数组</span></span><br><span class="line">mapped.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 根据索引得到排序的结果</span></span><br><span class="line"><span class="keyword">var</span> result = mapped.map(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list[el.index];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="reduce和reduceRight"><a href="#reduce和reduceRight" class="headerlink" title="reduce和reduceRight"></a>reduce和reduceRight</h3><p><code>array.reduce(callback,[initialValue])</code> reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">partial, value</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> partial + value</span><br><span class="line">	&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>].sum()</span><br><span class="line"><span class="comment">// &lt;- 28</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> input.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">partial, value</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (partial) &#123;</span><br><span class="line">			partial += <span class="string">', '</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> partial + value.name</span><br><span class="line">	&#125;, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line">concat([</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">'George'</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">'Sam'</span> &#125;,</span><br><span class="line">	&#123; <span class="attr">name</span>: <span class="string">'Pear'</span> &#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &lt;- 'George, Sam, Pear'</span></span><br></pre></td></tr></table></figure></p>
<p><code>arr.reduceRight(callback[, initialValue])</code> reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// total == 6</span></span><br><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// flattened is [4, 5, 2, 3, 0, 1]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><code>array.slice([begin[,end]])</code> slice不修改原数组，只会返回一个包含了原数组中提取的部分元素的一个新数组。原数组的元素会按照下述规则拷贝：</p>
<ul>
<li>对象引用(非对象直接量):slice方法会拷贝对象引用放到新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>
<li>字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): slice方法会拷贝字符串和数字的值放到新数组里.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(unboundSlice);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- ['a', 'b']</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.call(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- [&#123; 0: 'a', 1: 'b', length: 2 &#125;]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span> (<span class="params">text, bold</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bold) &#123;</span><br><span class="line">		text = <span class="string">'&lt;b&gt;'</span> + text + <span class="string">'&lt;/b&gt;'</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> values = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	values.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">		text = text.replace(<span class="string">'%s'</span>, value)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> text</span><br><span class="line">&#125;</span><br><span class="line">format(<span class="string">'some%sthing%s %s'</span>, <span class="literal">true</span>, <span class="string">'some'</span>, <span class="string">'other'</span>, <span class="string">'things'</span>)</span><br><span class="line"><span class="comment">// &lt;- &lt;b&gt;somesomethingother things&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p><code>array.splice(start, deleteCount[, item1[, item2[, ...]]])</code> splice() 方法用新元素替换旧元素，以此修改数组的内容。如果添加进数组的元素个数不等于被删除的元素个数，数组的长度会发生相应的改变。</p>
<ul>
<li>返回值 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</li>
<li>参数<ul>
<li>start 从数组的哪一位开始修改内容。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位。</li>
<li>deleteCount 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。</li>
<li>itemN 要添加进数组的元素。如果不指定，则 splice() 只删除数组元素。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ar source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line"><span class="keyword">var</span> spliced = source.splice(<span class="number">9</span>)</span><br><span class="line">spliced.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'removed'</span>, value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- removed 10</span></span><br><span class="line"><span class="comment">// &lt;- removed 11</span></span><br><span class="line"><span class="comment">// &lt;- removed 12</span></span><br><span class="line"><span class="comment">// &lt;- removed 13</span></span><br><span class="line"><span class="built_in">console</span>.log(source)</span><br><span class="line"><span class="comment">// &lt;- [1, 2, 3, 8, 8, 8, 8, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p><code>arr.indexOf(searchElement[, fromIndex = 0])</code>indexOf()方法返回给定元素能找在数组中找到的第一个索引值，否则返回-1。 indexOf 使用strict equality (无论是 ===, 还是 triple-equals操作符都基于同样的方法)进行判断 searchElement与数组中包含的元素之间的关系。searchElement:要查找的元素，fromIndex:开始查找的位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = [a, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(b.indexOf(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// &lt;- -1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.indexOf(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;))</span><br><span class="line"><span class="comment">// &lt;- -1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.indexOf(a))</span><br><span class="line"><span class="comment">// &lt;- 0</span></span><br><span class="line"><span class="built_in">console</span>.log(b.indexOf(a, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// &lt;- -1</span></span><br><span class="line">b.indexOf(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// &lt;- 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p><code>array.reverse</code> reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。简称逆序<br>reverse 方法颠倒数组中元素的位置，并返回该数组的引用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.reverse()</span><br><span class="line"><span class="comment">// [4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure></p>
<p>最后分享一段有趣的代码,在你的浏览器控制台中运行，页面中各层的HTML就会被不同的颜色标记出来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>是不是很好玩! :-)</p>

      
    </div>
  
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/24/js-call/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          JavaScript中call,apply,bind以及this的理解
        
      </div>
    </a>
  
  
    <a href="/2016/04/09/markdown-handbook/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Markdown简明语法手册&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-javascript-array" data-title="JavaScript原生数组" data-url="https://gnipbao.github.io/2016/04/23/javascript-array/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {short_name:'gnip'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->
</section>
</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Gnip&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo.</a>

    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>